+++
title = "Bi-directional Burrows Wheeler Transformationまでの道（3）：Suffix Tree"
date = 2020-04-25
draft = false
tags = []
order = 0
weight = 0
aliases = []
template = "page.html"
[taxonomies]
tags = ["Suffix Tree", "Algorithm", "Bioinformatics"]
categories = ["Bioinformatics"]
[extra]

+++


# これは何？

生物情報科学でごく希に出てくるデータ構造でbi-directional Burrows Wheeler Index(双方向バロウズウィーラー索引)というものがある。これは与えられた文字列内で繰り返し出てくる配列を高速に求められることと、やたらアルゴリズムがだるいことで知られている。

このシリーズはbi-directional Burrow Wheeler Indexを実装することを目的に、周辺のデータ構造を合わせて解説するシリーズにする予定であり、本稿はそれの第3回に当たる。

<!-- more --> 

# 参考文献

シリーズを通して

- Mäkinen, V., Belazzougui, D., Cunial, F. and Tomescu, A.I., 2015. Genome-scale algorithm design. Cambridge University Press.

を参考にしている。今回は

- Kasai, T., Lee, G., Arimura, H., Arikawa, S. and Park, K., 2001, July. Linear-time longest-common-prefix computation in suffix arrays and its applications. In Annual Symposium on Combinatorial Pattern Matching (pp. 181-192). Springer, Berlin, Heidelberg.

も参考にした。



# 本文

## 前回の訂正

前回、Suffix Arrayの構築でSuffix Array-Induced sortingを紹介したが、実は[Yuta-Mori's DivSufSort](https://github.com/y-256/libdivsufsort)の方が早いとの連絡を受けた。どうやらそのような場合もあるようなので、ここに追記する。

情報を教えてくれた方にここで感謝します。ありがとうございます。

## はじめに

前回からしばらく間が開いたが、遊んでいたわけでも、今回の内容が極めて難解だったからでもない。私が単に怠惰だったからだ。この中で怠惰でなかったものだけが私を打ちなさい。当然、紀元1世紀にいた気立てのいい若者がこういう言い訳をしたら、さすがにマグダラのマリアでも助走をつけて殴るレベルである。

さて、[前回](./../suffix_array2)はSuffix Arrayの線形構築をした。これで、ある程度高速にSuffix Arrayを構築できて、ある程度の時間で文字列検索が出来るようになったのだが、実は『ドキュメントに対して文字列があるかを検索する』というのではない応用例もある。

例えば、コードを書いて、その中で冗長なコードがあるかを探したいというモチベーションは誰にでもあるだろう（保守がしやすくなるため）。そのような場合、ソースコードの中に繰り返して現れる文字列を検索したい、という問題だと定式化できる。

ほかにも、ゲノムの中に同じように繰り返す配列がどのくらいあるかを調べたいということもあろう。例えば、転移因子の解析や、アラインメントの際に偽陽性を生んでしまうリピートの検出等だ[^1]。

つまり、

- 入力：文字列
- 出力：繰り返している文字列の場所たちと長さ（位置を表す整数のベクタと、繰り返し長を返す）

ただ、この『繰り返している』という言葉の定義は直感的には分かるものの、実はそんなに簡単でないことが分かる。つまり、

AAACTCAAACTCAAACTG

という文字列があった場合、繰り返している文字列は`AAACT`なのだろうか？　それとも`AAACTC`なのだろうか？　後者だという場合、なぜ前者は繰り返していると言えないのだろうか？　後者も含めると言った場合、`AAA`も繰り返しになるのではないだろうか？

つまり、我々は最大リピートの定義から議論を始めた方がよかろう。


[^1]: 専門家以外にはつらい表現だが、そういう問題があるくらいに思ってほしい。あります。


## 内容：繰り返し配列とSuffix Tree

さて、今後、繰り返している文字列のことをリピートと言ったり、反復配列とかいたり、繰り返し文字列と書くが、意味は全て同じである。それは文字列の中で二回以上繰り返している部分文字列のことだ。

先ほどの`AAACTCAAACTCAAACTG`で言えば、`AAACT`も`AAACTC`もリピートである。何なら`AAACTCAAACT`も重なっているが繰り返しているのでリピートである。何なら`A`も`C`も`T`も`G`もおけらもあめんぼも繰り返している[^1]。

そうはいっても、`A`を出力して「繰り返しです」と言われても少し困る。なぜかというと、もっと頑張れるからだ。`AA`は`A`があるところなら**どこでも**見つかる。`AA`を出力すれば`A`なんて出さなくてもいい。これが**右/左最大反復(right/left-maximal repeat)**の定義である。つまり、

### 右/左最大反復配列(Right/left-maximal repeat)

ある文字列\\(T\\)に対して、文字列\\(x\\)が右/左最大であるとは、\\(x\\)が\\(T\\)の部分文字列として二回以上現れ、それら部分文字列の全てを右/左に伸ばすことが出来ないという事である。

もう少し簡単に言えば、\\(T\\)に対して、文字列\\(x\\)がある場所を全て列挙して、それらの一つ前の文字が全部同じなら、それは左最大ではない。具体的に言えば、`AAACTCAAACTAAACTG`においては、`AAAC`は右最大ではないが（`AAAC`は全て`AAACT`の形で出てくるので、右に一つ伸ばせる）、`AAACT`は右最大である（`AAACTC`か`AAACTG`の二つの形があるので、『安全に』右には伸ばせない）。

もちろん、最大反復配列とは、右最大でも左最大でもある反復配列のことである。

さて、ではそんなのどうやって求めるんだという話だ。クエリとか文書とかそういうレベルの話ではないことは分かる。

ただ、Suffix Arrayを眺めると、各接尾辞が辞書順にソートされているので、繰り返している文字列を列挙するのは簡単に見える。馬鹿ほど出てくるが、`AAACTCAAACTAAACTG`のSuffix Arrayを書くと、

- `0:AAACTCAAACTAAACTG$`
- `1:AACTCAAACTAAACTG$`
- `2:ACTCAAACTAAACTG$`
- `3:CTCAAACTAAACTG$`
- `4:TCAAACTAAACTG$`
- `5:CAAACTAAACTG$`
- `6:AAACTAAACTG$`
- `7:AACTAAACTG$`
- `8:ACTAAACTG$`
- `9:CTAAACTG$`
- `10:TAAACTG$`
- `11:AAACTG$`
- `12:AACTG$`
- `13:ACTG$`
- `14:CTG$`
- `15:TG$`
- `16:G$`
- `17:$`

が

- `17:$`
- `00:AAACTCAAACTAAACTG$`
- `06:AAACTAAACTG$`
- `11:AAACTG$`
- `01:AACTCAAACTAAACTG$`
- `07:AACTAAACTG$`
- `12:AACTG$`
- `02:ACTCAAACTAAACTG$`
- `08:ACTAAACTG$`
- `13:ACTG$`
- `05:CAAACTAAACTG$`
- `09:CTAAACTG$`
- `03:CTCAAACTAAACTG$`
- `14:CTG$`
- `16:G$`
- `10:TAAACTG$`
- `04:TCAAACTAAACTG$`
- `15:TG$`

になるので[^2]、なんとなく`AAACT`が最初に出てくるし、`ACT`もそれっぽいなあとか思える。ならそのようにデータ構造を作ってみよう。

つまり、これらの接尾辞たちを**できるかぎりマージしながら**木構造を作っていく。そして、葉としてはこれらの接尾辞にたどり着くようにしよう。絵で描くと次のようなものを作る。

{{resize_image(path="blog/suffix_array3/suffix_tree.png", width=500, height=500, op="fit_width", alt = "Suffix Tree", title = "Suffix Tree")}}


例えば、Suffix Arrayで最初の接尾辞`$`は特にマージするものもないので、直接Suffix Arrayの0番目にたどり着く。次のSuffix Arrayで言うと1-9番目までの接尾辞は全て`A`から始まるので、`A`のラベルを持った辺を頂点から伸ばす。1-6までの接尾辞は、もう一つ`A`を共有するので、そういう感じにする。1-3番目まではさらに`ACT`を共有するので……という感じだ。一本道になったところのラベルは削ってある[^3]。

このようにして木を作ったら、各頂点のラベルを『根からその頂点まで行くまでに出会う文字列』と定義する。例えば、上の図の青い点のラベルは`A`であり、赤い頂点のラベルは`AAACT`である。

（この木は枝が交差しないように描かれていることに気がついただろうか？　実は、一番下の配列をSuffix Arrayにして、ある頂点から引く枝のラベルを、左から小さくなるようにすると交差しないように描ける。これは交差したら接尾辞の大小関係が終わってしまうからだ）

専門的には、この木はコンパクトトライと言われるが、どうでもいい。実はこれは**Suffix Tree**と呼ばれていて、形式的な定義は『文字列\\(T\\)の接尾辞全てからなるコンパクトトライ』だが、まあそういうことだ。


こうすると、なんとなく`AAACT`はリピートっぽいな、だって0,6,11が共有してるから、みたいな事を考えられるようになる。これはなんとなく使える気がする。


事実、この木(**Suffix Tree**)を使うことで、最大反復配列を見つけることができる。

まず、それぞれの葉でない頂点は右最大であることに注意しよう。というのも、もし右最大でないなら、『まだマージできる』ことになるからだ。例えば、上の図の青い頂点は右最大である。`A`が右最大なのはなんとなく納得いかないが、`AC`や`AA`などが文字列中に出てくるから、確かに安全には伸ばせない。もちろん、`AAACT`も右最大である。これは0,6,11の親のノードに対応している。

要するに、問題は、これら葉でない頂点たちが左最大でもあるかどうかを調べればいい。

ところで、例えば、赤い頂点は`AAACT`に対応しているが、これらは当然、その下の葉たち(0, 6, 11番目から始まる文字列たち)の接頭辞でもある。つまり、

- `T[0..]=AAACT...`
- `T[6..]=AAACT...`
- `T[11..]=AAACT...`

である。この頂点が左最大でもあるかどうかを調べるなら、各接頭辞の前の文字を調べればいい。それらが全て同じなら、まだ左側に伸ばせるので左最大ではない。相異なるものがあるなら、左最大である。

ところで、これは`T[0..]`の接頭辞を含んでいるので、当然左には伸ばせない。よってこれは左最大である。

一方で、その横の`T[1..],T[7..],T[12..]`は全て`AACT`から始まる。ところが、`T[0],T[6], T[11]`は全て`A`から始まるので、これはまだ左に伸ばせる。つまり、左最大ではない。

このようにして、どんどん、Suffix Treeの下の方から左最大かどうかを決定していきたい。そのためには、Suffix Treeの各頂点`v`に対して、『`v`のラベルを接頭辞として持つ接尾辞たちが、一つ前に同じ文字を持つか、持つとしたら何か』を`p`として、次の再帰方程式を評価すればいい。

`p[v]`は

1. `v`が`T[0..]`に対応する葉のとき、`None`。
2. `v`が`T[i..]`に対応する葉であり、`i > 0`の時、`Some(T[i-1])`。以上で`v`が葉に対応するケースを尽くす。
3. `v`の子が全て同じ`p[_]=Some(c)`を持つとき、`Some(c)`
4. そうでないとき、`None`。これで`v`が内部頂点の時の場合を尽くす。

となる。子の`p`が全て`None`の時も`None`になることに注意しよう。

明らかに、もし`v`のラベルが`Some(c)`なら、`T`中に出てくる`v`のラベルを表す全ての接頭辞たちの一つ前の文字は`c`である。つまり、左最大ではない。

よって、上の`p[v]`を全長点に対して計算した後で、`p[v] = None`なる頂点を探せば、それは左最大かつ右最大、つまり最大反復配列である。


### Suffix Tree の構築

という訳で、Suffix Treeを作ると、最大反復配列を見つけられたわけだが、Suffix Tree自体をどう作るかは言っていなかった。とにかくマージすればいいよね、と言っていたが、具体的な作り方は不明だった。


もう一度、`AAACTCAAACTAAACTG`のSuffix Treeを見てみよう。

{{resize_image(path="blog/suffix_array3/suffix_tree.png", width=500, height=500, op="fit_width", alt = "Suffix Tree", title = "Suffix Tree")}}

分かることとして、Suffix Arrayの`i`番目に向かうパスは、`i`までのSuffix Treeが構築できていれば構築できる、という事がある。要するに、再帰的に作っていくと心に決めることができる。

さて、\\(ST_i\\)で、Suffix Arrayの`i`番目の要素までを使って構築したSuffix Treeを表すことにしよう。このとき、\\(ST_{i+1}\\)を作る、つまり、`i+1`番目の接尾辞を使いすればいい。要するに、`i+1`番目の接尾辞がどのくらいマージできるかを調べればいい。



さて、このとき、実は`i`番目の接尾辞とどれだけ共通した文字列を持っているか知っていればいいことに注意しよう。`i`より前の接尾辞とどのくらいマージできるかは関係ない。この数値`LCP`(largest common prefix: 最大共通接頭辞)を持っていれば、次のような手続きで`i+1`をマージすることができる。



1. `i`番目の接尾辞を表す葉を`v`とする。
2. `v`のラベル（根から`v`までに通る文字列）の長さが`LCP[i+1]`以下になるまで親をたどっていく。
3. もし、`v`のラベルの長さが`LCP[i+1]`と同じなら、根から`v`までマージできるという事である。`v`から`i+1`番目の接尾辞を表す葉に辺を引く。ラベルはしかるべく定める。
4. そうでないなら、新しい頂点`w` を作って、`v->w->s`という辺を追加する。ここで、`s`は`i+1`番目の接頭辞を表す葉である。ラベルはしかるべく定める。



各ステップで、`v`の親にたどり着くと、今後`v`には到達しない事が分かる。なぜなら、`v`の親に到達すると、そのステップでは`v`か、それの上の頂点から新しい辺が引かれ、今後は必ずそちらの辺を通るからである（図を描こう）。したがって、合計の計算量は頂点数に対して線形であることが分かる。



よって、**もし`Suffix Array`と`LCP`配列があれば**、線形時間でSuffix Treeが構築できることが分かった。それはそれでいいのだが、これはまだ問題を先送りにしている。LargestCommonPrefixをどう作るんだという話である。



### LCPの線形時間構築



さて、LCPをもうちょっと真面目に定義しよう。LCP(Largest Common Prefix:最大共通接頭辞)配列とは、



`LCP[i]=T[SA[i]..]とT[SA[i-1]..]の最大共通接頭辞の長さ`言い換えると、\\(\max_l{ l s.t. T[SA[i]..SA[i]+l] = T[SA[i]-1..SA[i-1]+l] } \\)である。

重要なことは、`i`はランキングである。接頭辞の順番である。`LCP[i]`は`i`番目に小さい接頭辞と、`i-1`番目に小さい接頭辞を比べている。引数は接頭辞のランキングである。しつこいが重要だ。

これをどう計算するかだが、例によってSuffix Arrayを酷使する。まず、Inverse Suffix Arrayというものを作る。これは要するに`SA[ISA[i]] = i `かつ`ISA[SA[i]] = i`を満足するような配列だ。正直意味不明だ。


まず、`SA[i]`とは、接頭辞たちをランキング付けしたときに`i`番目になる接頭辞の始まるポジションである。したがって、`ISA[t]`とは、`t`番目の接頭辞(`T[t..]`)が接頭辞ランキング何位か調べる配列である。もっというと、`Rust`のコードブロック

```rust
{
	let mut isa = vec![0;sa.len()];
	for (rank, &idx) in sa.iter().enumerate(){
		isa[idx] = rank;
	}
	isa
}
```

で返ってくる配列である。

この`ISA`を使って、`LCP`を計算してみよう。ここでテクとして、`T[0..]`に対応するスロットから埋めることにする。

まず、`T[0..]`のランキングは`ISA[0]`なので、`LCP[ISA[0]]`を埋めることにする（`LCP`の引数は=> ____ ）。つまり、`T[SA[ISA[0]]..]=T[0..]`と`T[SA[ISA[0]-1]..]`を比べればいい。

これは実際に一文字ずつ計算して、`LCP`を計算する。**こうして得た値をlとしよう。**

次に、一文字目から始まる接尾辞に対応するスロットを計算する。`T[1..]`に対応するスロットだ。ランキングは`ISA[1]`なので、`T[1..]`と`T[SA[ISA[0]-1]..]`を比べればいい。

ところで、これは0文字目からマッチを計算する必要は実はない。最低でも`l-1`はマッチするのだ。なぜかというと、さっき、`T[0..]`とのマッチを計算して`l`あったので、`T[1..]`と一番近い配列のマッチ長が`l-1`より短かったら、「おいさっきのマッチどこ行ったんだよ」という話になるからだ。

こうして、前回のマッチ長`l`を持ちながら、`T`を前から順に、`ISA`,`SA`を使いながら力任せに`LCP`を埋めていけばいい。

一瞬、毎回、最大`|T|`長のマッチが発生するので、入力長に二乗の時間がかかりそうだが、前回のマッチ長`l`は一回のループでたかだか1しか減らないし、最大`|T|`なので、線形の時間で終わる。


## 最後に

ずいぶん時間がかかったが、とにかくSuffix Treeまで終わった。ところが、色々まだ問題がある。それは、Suffix Tree/Arrayがやたらメモリを食うというところだ。実際、各接尾辞の位置を表すのに\\(\long n \\)かかるので、合計で\\(n \log n \\)くらいのメモリを消費する。実際は64bit=8byteで表すことになるので、3G塩基のヒトゲノムを表そうと思うと、24Gbyteくらいかかる。これはまあまあ大きい。ちょっとでかいデータセットだと、平気で数十Gくらいあるので、200Gbyteくらい食われる。さすがにやめてくれという気持ちになる。

そのような状況でよく使われるのが、Burrows-Wheeler Transformationというデータ構造である。これはわりあいメモリを食わない。次はこれがなんであるかを説明して、実装しよう。

------

[^1]: 当然、最後の二つは繰り返していない。もちろん、いのちの輪廻の観点から見れば、これは繰り返している。

[^2]: これは卑劣な行数稼ぎではない。

[^3]: ではなぜ`$`のラベルを削らなかったという話に発展するが、要するにその場のノリである。