+++
title = "最短共通包含文字列問題Shortest Common Superstring Problemについて"
date = 2018-09-28
draft = false
tags = []
# category = "diary"
order = 0
weight = 0
aliases = []
template = "page.html"
[extra]
+++

## 今日書くこと

今日はShortest Common Superstring Problemという問題がNP完全であることを示す。

なんで突然こんな話を始めたかと言うと、これはゲノムアセンブリに関わっているからで（最近、ゲノムアセンブリについて
ずっと書いているが、僕は別にゲノムをアセンブルするような趣味も研究もしていない）、具体的には、次のようになる。

ゲノムアセンブリ（短いDNA断片から、元のゲノムを復元する）は、要するに、DNA断片の集合から、それらを
うまく『説明』するような配列を生成しろ、という問題だと思うことが出来る。

この『説明』というのが難しく、一体何を持って説明とするかは議論の分かれるところである。

例えば、*すべてのDNA断片を部分文字列として含む*というのを、『説明する』ことだとすると――確かに、
この定義は、DNA断片が虚空からではなく、ゲノムから読まれていると言うことは保証してくれるが――
色々と問題がある。

というのも、この定義に則って言えば、得られたDNA断片をすべて連接（つなげて）出力したものも、
DNA断片を『説明する』事になってしまうからだ。
もちろん、ゲノムを何十回・何百回を読んだ結果としてDNA断片たちが得られていると考えると、
このアセンブリは長すぎる。

この『長過ぎる』ということを逆手に取って、では、次のように定義してみてはどうだろうか。

> 『説明する』とは、すべてのDNA断片を部分文字列として含むような文字列のうち、かなり短いものである

もちろん、問題を*かなり*の部分に押し付けているだけなのだが、これを*最も短い*としたものが、
まさにShortest common superstring problemという問題である。

今日は、この問題の厳密な定義から始めて、これが難しいことを示す。
論文としては、

Gallant, J., Maier, D. and Astorer, J., 1980. On finding minimal length superstrings. Journal of Computer and System Sciences, 20(1), pp.50-58.(https://doi.org/10.1016/0022-0000(80)90004-5)

をほぼ完コピします。

<!-- more -->

### definition
#### Shortest Common Superstring Problem]
あるアルファベット$\Sigma$と、その上の文字列の集合$S=\{s_1,s_2,\cdots,s_n\}$が与えられたときに、$S$のShortest Common Superstringとは、
$S$内の全ての文字列を部分文字列として含むような、$\Sigma$上の文字列のうち、最短のものと定義する。
どのような$S$に対しても、自明にShortest Common Superstringはある。

Shortest Common Superstring Problem(SCS)とは、次のような決定問題である。

INSTANCE:アルファベット$\Sigma$、$\Sigma$上の文字列の集合$S$、自然数$K$。

QUESTION:$S$に対する長さ$K$のShortest Common Superstringは存在するか。
\\end{definition}

\begin{remark}
まず、この問題がNPであることは明らか。実際、ある文字列が$S$の要素全てを含むかは、$S$の要素を一つずつチェックすれば多項式時間で済むので、
Yesインスタンスに対して、オラクルとして長さ$K$のShortest common superstringを提示すれば、多項式時間でYesインスタンスであることを確証できる。

さらに、QUESTIONの部分を『$K$以下の長さの』としても、問題の難しさは変わらない。
実際、$K=0$のときには必ずNoが、$K=\sum_{s\in S} \|s\|$のときには必ずYesが返ってくることを用いれば、
二分探索によって、多項式還元ができる。

また、注意すべきこととして、この定義はそもそもよい定義になっているかということがある。
というのも、ゲノム中には複数出現する配列があり（というのも、この世には全ゲノム重複や転移因子などがあるため）、
したがって、実際のゲノムはshortestなものではないことがほとんどだからである。
\end{remark}

証明の方針としては、ハミルトン閉路問題をSCSに還元することにする。
つまり、ハミルトン閉路問題を多項式時間でSCSの問題に変換することが出来て、この時に、変換前と変換後でYes/Noが変化しなければ、ハミルトン閉路問題を簡単に解くことが出来ないのだから、したがって、SCSも簡単には溶けないのだと結論する（さもなければ、変換してSCSをとけば、簡単にとけたことになってしまう）。

とは言え、直接ハミルトン閉路を用いるのは大変なので、まず、次のような問題を考える。

\begin{definition}[Hamilton Cycle Problem,Extended Hamilton Path Problem]
ハミルトン閉路問題（Hamilton Path Problem）とは、

INSTANCE:有向グラフ$G=(V,E)$

QUESTION:グラフはすべての頂点をちょうど一回だけ通るような閉路を持つか

であり、拡張ハミルトンパス問題（Extended Hamilton Path Problem）とは、

INSTANCE:有向グラフ$G=(V,E)$であり、以下の条件を満たすようなもの
\begin{enumerate}
    \item ある$s,t \in V$があり、$IN(s)=0$ かつ $OUT(t)=0$を満たす。
        \item 上記の$t$以外すべての頂点$v$について、$OUT(v) \geq 2 $が成立する
	\end{enumerate}

QUESTION:グラフは$s$から$t$まで、すべての頂点をちょうど一回だけ通るようなパスを持つか。
\end{definition}

さて、やや意外だが、ハミルトン閉路問題と拡張ハミルトンパス問題は同じくらい難しい。

\begin{lemma}
ハミルトン閉路問題$P$を、多項式時間で拡張ハミルトンパス問題$P'$に変換することができ、この時、"$P$の答えがYes　$\iff$ $P'$の答えがYes"　が成立する。
\end{lemma}
\begin{proof}
実際に、変換を作る。ハミルトン閉路問題のグラフを$G=(V,E)$とする。ここで、$G$はただ一つの連結成分からなるようにしてよい。特に、すべての頂点$v$について、$OUT(v)\geq1$が成立していると考えてよい。さもなければ、ハミルトン閉路はないので、適当にハミルトンパスのない、条件を満たすグラフを『変換したもの』として返せばよい。

\begin{enumerate}
    \item 適当な頂点$v$を$G$から取り除き、$G$に$t$、$s$を付け加え、$v$から出る辺をすべて$s$から出るように、$v$に入る辺をすべて$t$に入るように付け替える。（よりわかりやすく言うと、$v$を2つの頂点に裂いて、入る辺と出る辺を切り離す。この$s$、$t$を拡張ハミルトンパス問題の開始$s$と終端$t$に対応させたい。）
        \item 2を満たすために、新しい頂点$t'$を$G$に追加する。更に、2つの頂点$a,b$を$G$に追加して、次の辺を付け加える:$(t,a),(t,b),(a,b),(b,a),(a,t'),(b,t')$。更に、$t'$以外のすべての頂点は少なくとも出次数が1あることを考えると、$OUT(v)\geq 2$を満たさないような頂点$v$から、満たすように$t'$に引けばよい。
	\end{enumerate}
	結局、この変換されたグラフ$G'$においては、$s$の入次数が0、$t'$の出次数が0になり、$t'$以外の出次数は少なくとも2はあることになった。

さて、気になるのは、$G$がハミルトン閉路を持つ$\iff$ $G'$が$s$ から $t'$へのハミルトンパスを持つ

は成立するだろうか？　

$\Rightarrow$

今、$G$のハミルトン閉路を、$G'$を作る時に消した$v$の位置で区切って、$P:v \rightsquigarrow v$という風に書く。この時、スタートの$v$を$s$に取り換え、ゴールの$v$を$t$に取り替える。
それから、$t \rightarrow a \rightarrow b \rightarrow t'$と道を付け足せば、$s$から$t'$へのハミルトンパスが構築できた。

$\Leftarrow$

今、変換後のグラフ$G'$において、ハミルトンパス$P':s \rightsquigarrow t'$が見つかったとする。この時、まず、手順2で追加した$a,b$が$t'$か$b,a$にしか辺を持たないので、$a,b$に行くと、自動的に$t'$に行かざるを得ないので、かつ、$t'$に行くのはゴールするときしかありえないので、次のことがわかる。
\begin{center}
    $P':s \rightsquigarrow a \rightarrow t'$か

    $P':s \rightsquigarrow b \rightarrow t'$の
    \end{center}

いずれかである。また、$a,b$に向かう辺は$t$からしか伸びていないことを考えると、

\begin{center}
    $P':s \rightsquigarrow t \rightarrow a \rightarrow t'$か

    $P':s \rightsquigarrow t \rightarrow b \rightarrow t'$の
    \end{center}

いずれかである事がわかる。この$s \rightsquigarrow t$の部分では、$(v,t')$の形の辺は使われるはずがないので、そのまま$s,t$を$v$に置き換えれば、$G$上のハミルトン閉路と見ることができる。
\end{proof}

要するに、ハミルトン閉路問題は\textbf{すべて、Yes/Noを変更することなく}拡張ハミルトンパス問題に多項式時間で変換できた（多項式還元出来た、という）。拡張ハミルトンパス問題を解くアルゴリズムAがあるとすると、ハミルトン閉路問題を、拡張ハミルトンパス問題に変換してAで解くことが出来る。

ところで、ハミルトン閉路問題は、それ自身、\textbf{どんなNP問題も、ハミルトン閉路問題に多項式時間出来る}という性質を持っている（NP完全、という）ので、拡張ハミルトンパス問題もNP完全である。
\footnote{説明がダルいのはわかるが、この還元の向きはとても大切で、変換が全射である必要がないというのも大切}


では、次に、SCSと拡張ハミルトンパス問題が同じくらい難しいことを示そう。

\begin{theorem}[SCS-NPC]
拡張ハミルトンパス問題は、多項式時間で、問題のYes/Noを変えずに、SCS問題に変換することができる。
\end{theorem}
\begin{proof}
実際に多項式還元を構築することで示そう。

まず、拡張ハミルトンパス問題のインスタンスを$G=(V,E)$とする。ここから、次のようにSCSの問題を作る。

ここで、$V$は有限集合なので、$\{1,\cdots n\},n = |V|$と同一視する。さらに、適当に対応させることで、$s=1,t=n$となるようにしておく。

アルファベットとしては、次のものを用いる。
\begin{equation}
    \Sigma = \{v,\bar{v}\mid v \in V \} \cup \{\#,\$,\S\}
    \end{equation}
    例えば、$\{1,\bar{1},2,\bar{2},\cdots,\bar{n},\#,\$,\S \}$のようになる。

次に、文字列を作る。まず、$n$\textbf{以外}の各頂点$v\in V$に対応する文字列の集合$A_v$を作る。
$v$に隣接する頂点(つまり、$(v,w)\in E$を満たすような$w$)の集合を、並び順を付けて$R_v = \{w_0,\cdots, w_{OUT(v)-1}\}$とする。例えば、頂点3が$\{4,5,6\}$への辺を持っていた場合、$R_3$としては、 $\{w_0,w_1,w_2\} = \{4,5,6\}$ととってもいいし、$\{w_0,w_1,w_2\} = \{4,6,5\}$ととってもいい。要するに、$v$の隣接頂点の『配列』を$R_v$と置く。

$A_v$は次の$2OUT(v)$個の文字列からなる集合をする。

\begin{equation}
    A_v = \bigcup_{w_i \in R_v} \{\bar{v}w_i\bar{v}\} \cup \{w_i \bar{v} w_{i\oplus 1}\}
    \end{equation}

ただし、$\oplus$は
例えば、上の例$R_3 = \{w_0,w_1,w_2\} = \{4,5,6\}$を用いると、$A_3 = \{\bar{3}4\bar{3},\bar{3}5\bar{3},\bar{3}6\bar{3}, 4\bar{3}5,5\bar{3}6,6\bar{3}4\}$となる。

次に、$1,n$以外のすべての頂点$v$について、$C_v = \{v\#\bar{v}\}$を作る。

最後に、$T= \{\S \# 1,n\#\$\}$を作る。

SCSのインスタンスとしては、上の文字列を全てまとめて、
\begin{equation*}
    S=\bigcup_{1\leq v < n} A_v \cup \bigcup_{1<v<n} C_v \cup T
    \end{equation*}
    として、$K=2n + 3m$ where $n = |V|,m=|E|$とする。

さて、この変換は明らかに入力長に対して多項式時間で計算できる。問題は、この変換が、Yes/Noを変えていないかどうかだ。つまり、

\begin{center}
    $G$が拡張ハミルトンパスを持つ $\iff$ $S$が長さ$K$のSCSを持つ
    \end{center}
    が成立しているかどうかだ。
    $\Rightarrow$のほうが簡単なので、先にこちらかからやる\footnote{だいたい、還元を行ったときは、こちらの方向が簡単になることが多い。}。上記の構成の直感も、これから得られるだろう。

$\Rightarrow$

まず、$A_v$と$w_i \in R_v$に対して、$w_i$標準文字列($STD(v,w_i)$と書く)を定義しよう。
これは、単に$A_v$内の文字列を、$\bar{v}w_i\bar{v}$から初めて、できるだけ短くなりそうなように重ねたものである。
具体的に言うと、
\begin{equation}
    STD(v,w_i) = \bar{v}w_i\bar{v}w_{i\oplus 1}\bar{v}w_{i\oplus 2}\cdots w_{i \oplus OUT(v)-1}\bar{v}w_i
    \end{equation}
    のことである\footnote{これは実際、最も短いのであるが、このことを証明する必要はない}。$A_v$内の要素がすべて$STD(v,w_i)$に入っていること、長さが$2OUT(v)+2$になっていることを確認してもらいたい。

ここでの直感は、次のようになる：ハミルトンパスにおいて、$(v,w_i)$という辺を使っていたならば、それをSCSにおいては、$STD(v,w_i)$という文字列に対応させることにする。

どのような$w_i\in R_v$からでも、$STD(v,w_i)$を作ることができ、更に、$STD(v,w_i)$は、$\bar{v}w_i$から始まり、$\bar{v}w_i$で終わることを覚えておこう。
要するに、$C_{w_i} = w_i\#\bar{w_i}$を使うと、『いい感じ』に$STD(v,w_i)$と$STD(w_i,\_)$を連結することができる。

実際、$G$におけるハミルトン閉路を$1\rightarrow p_2 \rightarrow \cdots p_{n-1} \rightarrow n$とした時、

$\S \# 1$から始めて、$STD(1,p_2),p_2\#\bar{p_2},STD(p_2,p_3),\cdots,STD(p_{n-1},n),n\#\$$を重なりの長さ2で重ねると、

\begin{itemize}
    \item それぞれの$STD(\_,\_)$は重ならないので、長さは合わせて$\sum_{v\in 1..v-1}2OUT(v)+2 = 2m+2(n-1)$
        \item それぞれの$v\#\bar{v}$は$\#$以外は左右の$STD(\_,\_)$で吸収出来るので、長さは合わせて$n-2$。
	    \item $\S \# 1,n\#\$$は$\S \#,\#\$$の分で4
	    \end{itemize}

だけかかることになり、結局、この文字列は全体として$3m+2n$長になり、ぴったりSCSの要求に合致する！

$\Leftarrow$

今、変換したSCSの問題がYesのインスタンスだとする。つまり、$\Sigma$上の$2m+3n$長の文字列$P$があって、$s$は、$S$内のすべての文字列を部分文字列として含むとする。

この時、$G$において、$1\rightsquigarrow n$なるハミルトンパスを構築しなければならない。

次のように示す。

\begin{enumerate}
    \item どう頑張っても、変換したSCSの問題においては、Common Super Stringは$2m+3n$長より短く出来ないことを示す。
        \item $2m+2n$長を達成する文字列は、$\Rightarrow$で構築したような文字列でしかありえないことを示す。
	    \item このような文字列を$\Rightarrow$でやったのとは逆向きにパースして、ハミルトンパスを構築する。
	    \end{enumerate}

まず、$S$内のどの2つの文字列も、含む・含まれるという関係にはない。したがって、$S$内の任意の文字列は、最大でも(長さ)-1しか重複しない。
また、$S$内の文字列は、すべて長さ3である。
したがって、どのように重複させても、必ず、$S$内の文字は1の長さを必要とするので、$P$は

\begin{equation}
\sum_{v \in 1..n-1}2OUT(v) + \sum{v in 2..n-1} 1 + 2 + 2 = 2m + n + 2
\end{equation}

以上の長さを必要とする（一項目は$A_v$たちに、二項目は$C_v$たちに、三項目の$2$は$T$に、4項目の2は、文字列の最後は重複をさせることができないことに対応する）。

ここで、$v\#\bar{v}$という形の文字列は、$v\#,\#\bar{v}$という部分文字列が他に出てこないので、画像のように、必ず1の重複しか許さない。したがって、$v\#\bar{v}$一つにつき、前後で2だけ重複は減る。

したがって、$v\#\bar{v}$は$n-1$個あるので、結局、$2m + n + 2 + 2(n-1) = 2m + 3n$がCommon Superstring$P$の長さの下限となる。

また、実際には、$\S,\$$という2つの文字列は$T$以外には出現しないので、$T=\{\S 1\#,\#n\$\}$は最大でも長さ2の重複しか持たず、この時、$\S1\#$は文字列$P$の最初に、$\#n\$$は文字列$P$の最後になる。

更に、$P$内の、連続した2つの$\#$の間の文字列$x$を取ってこよう。
この時、$\#$は$v\#\bar{v}$にしか出てこないので、$x = \bar{v}\cdots w$の形をしているはずである。

更に、$\bar{v}$から始まる文字列は$\bar{v}w_i\bar{v}$しかなく、この先の文字列は、必ず$\bar{v}w_i\bar{v}$と長さ2の重複を持たなければならないため、$w_i\bar{v}w_{i\oplus1}$でしかありえない\footnote{本当は背理法を使うべきだが、冗長になるのでこのように書いている}。

同様に考えて、この次は$\bar{v}w_{i \oplus 1}\bar{v}$になる。
さて、このような推論を続けていくと、$A_v$以外の文字は使えないことがわかるが、$A_v$内の文字を全て使い尽くすことは必要だろうか？
この疑問の答えがはいであることは、次の事実から従う:
$A_v$内の要素は、$A_v$の要素以外とは、最長でも1以下の重複しか持たないため、他の場所で$A_v$の要素を部分文字列として埋め込むと、上記で表した下限を満たすことができない。

よって、$x$は$A_v$の要素をすべて含み、かつ、$\bar{v}w_i\bar{v}$で始まる。
このような$x$は$STD(v,w_i)$しかない。

上記の議論をまとめると、$P$は次のような形をしている。

\begin{equation}
    P = \S\# STD(1,p_2)\# STD(p_2,p_3) \# \cdots \# STD(p_{n-1},n)
    \end{equation}
    ここで、$p_i,i=2,3,\cdots n-1$はそれぞれ$R_1,R_2,\cdots R_{n-1}$の要素である。

したがって、$P$から、$G$における$1$から$n$へのパスを、$1\rightarrow p_2 \rightarrow p_3 \cdots \rightarrow p_{n-1} \rightarrow n$と構築することができる。
これがハミルトンパスになっていることは、全ての頂点を通っていて($\begause$全ての$A_v$を使っている)、同じ頂点に二回行っていない($\because$各$STD(v,w_i)$で$A_v$の要素全てを使っている)ことから、明らかである。

\end{proof}

よって、SCSが多項式時間で解けるアルゴリズムがあったとすると、上記の変換を用いて、ハミルトン閉路問題も多項式時間で解けることになるが、これはハミルトン閉路問題が難しそうだという予想に反する。
言い換えれば、SCSはNP完全問題であり、文字列の集合から、SCSを返すという問題は\footnote{これは決定問題ではない}NP困難である。

ところで、悪い人はこのように主張するかもしれない。

\begin{quote}
       確かに、一般の$\Sigma$上の文字列に対してはそうかもしれません。
           しかし、私達が扱っているのは、本当に少ない数の文字で表される配列なんですよ。特に、$\Sigma = \{A,T,G,C\}$の時のことを考えてください。
	       もしかしたら、このときはSCS問題は簡単に解けるかもしれません。
	       \end{quote}

この人が言いたいのは、要するに、SCS全体を高速に解くアルゴリズムはないかもしれないが、SCSの一部の問題に限れば、高速に解けるのではないか、ということだ。

この主張は、実際、合理的で、例えば、$\Sigma = \{1\}$という一文字しかないアルファベット上のSCSは自明に$O(1)$で解ける。
他にも、例えば、文字列の長さが、すべて2以下のSCSについても、線形時間で解ける\footnote{アルゴリズムを考えてみよう。}。

しかし、アルファベットの大きさを4に制限しても、SCSの難しさは変わらない。
つまり、一般のSCSのインスタンスから、アルファベットの大きさを4文字に制限したSCSへの変換$f$を作ることができて、しかも、Yes/Noが変わらないようにできる。

これは簡単で、一般のSCSにおけるアルファベット$\Sigma = {a_1,a_2,\cdots, a_n}$を、3つの塩基$A,T,G$を使って、次のスキームにしたがってエンコードすればいい。

\begin{enumerate}
    \item $a_i$について、$A,T$を$0,1$と思って、$i$の2進数表現$[ i ]$を作る。
        \item $G$を"区切り文字"だと思って、$[ i ]G$と、エンコードしたインデックスの最後につなげる。
	\end{enumerate}

この時、$K$の値はどのように変換されるのか、また、変換前と変換後で、Yesに属するかどうかが一致するのかは、練習問題とする。

以上で、ゲノムアセンブリの計算量的な困難性は示すことができた。
