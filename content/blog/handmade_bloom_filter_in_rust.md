+++
title = "手作りデータ構造：BloomFilter to count k-mers in a dataset"
date = 2019-03-28
draft = false
tags = []
# category = "diary"
order = 0
weight = 0
aliases = []
template = "page.html"
[extra]
+++

## これは何？

データ内のk-merを数えるためのBloomFilterをRustで実装するときのテクについていくつか書いたもの。

- k-mer: 長さkの文字列のこと。k-gramと同じものを指す。例えば、"AAA"は3-mer。
- BloomFilter:　複数のハッシュ関数を用いて、要素のフィンガープリントを作ることで、Hashableな要素からなる集合をコンパクトかつ高速に表すためのデータ構造。
- Rust: Rustとは、安全性、平行性、そして速度に焦点を当てたシステムプログラミング言語です。

今回は諸事情があって、文字列をアルファベット{A,C,G,T}上のものに絞る。

実装は[bitbucket.org](https://bitbucket.org/yoh_ikkaidoh/handmade_bloom_filter/src/master/)においてある。

<!-- more -->

## コンテンツ

さて、ある文字列中の\\( k )\\-merすべてを、集合として扱いたい時がある。例えば、データの中にどのくらいユニークな\\( k )\\-merが含まれているか、とか、データから1回しか現れない\\( k )\\-merを取り除きたい、とかいうタスクは、バイオインフォマティクスでは頻繁に起こる。
発展的な課題として、各\\( k )\\-merが何回現れるかを知りたいという要望もあるが、ここではひとまずおいておこう。

（このようなタスクが起こる理由を簡単に述べる：同じファイルから『エラーあり』で、100回くらい読み込むことを考えよう。ここで、エラーあり、とは、大体1パーセントくらいの割合で読み間違えることを指すとする。
このとき、読んできたダンプの中から、エラーでない部分文字列をどうやったら回収できるだろうか？　簡単な推測として、100回読んでいるわけだから、大体どの部分文字列も、ダンプの中で100回以上はだいたい出ていると思われる。もちろん、同じ文字列が2回現れると、だいたい200回くらい見ることになる。

こうなると、逆に考えて、1回しか現れる\\( k )\\-merは、たぶん読み間違えた文字を含んでいると考えるのが良さそうだ。
つまり、これまでに出くわした\\( k )\\-merをすべて記録しておいて、2回目に現れる\\( k )\\-merからのみ残しておけば、荒っぽいとはいえ、エラーを取り除ける。

また、全体で何回読んだかわからないときでも、大体どのくらいの\\( k )\\-merがあるかを調べれば、元のファイルのだいたいの大きさが、なんとなく推測できるはずだ。
）

集合を取り扱う方法はいろいろあり、例えばBinary Treeを使って各\\( k )\\-merを持っておく、Hash Tableを使う、などがあげられる。

まず、前者について考えてみよう。各\\( k )\\-merの比較に\\( O(k) )\\かかり、1回の挿入には大体\\( O(k * log kN) )\\だけかかる。全部を合わせると、
\\( O(kN log kN) )\\くらいかかる。ここで\\( N )\\はデータの大きさを表す。

また、メモリを考えると、ナイーブな実装 -- 各ノードに対して、\\( k )\\文字列を保存する方法 -- だと、データサイズに\\( k )\\をかけて、\\( k )\\-merの数を足した分だけ必要になる。というのも、各ノードを表すのに、ヒープに確保された文字列（8 * k bit。DNAに特化すると 2k bit）とメモリへのポインタ(64bitが多いだろうか？)ぶんかかるためだ。

一見、このメモリ消費量は、読んだ文字列をそのままにしておいて、各ノードが、指定された\\( k )\\-merが初めて現れたデータの場所へのポインタを指すようにすれば、小さくできるように見える。しかし、これも結局、ノード数に比例したメモリが必要になる。

文字列がHashできることを活かして、巨大なHashTableを作って、適宜Maskingを調整しながらTableを拡張することで、\\( k )\\-merの集合を表したときのことを考えてみよう。こちらの計算量は\\( O(nk*hash(n)) )\\になる。ここで、Hashは\\( k )\\-merのハッシュ関数がどのくらいで計算できて、ハッシュテーブルのルックアップの解決にどれくらい時間がかかるかを示す。
潤沢にメモリがあれば、これはデータ量に線形に増えているように思われる。

しかし、メモリの消費量は問題になる。というのも、HashTableを実装するときには、各キーとそのハッシュ値を格納しておくことが必要となるためだ（さもなければ、ハッシュが衝突したときに、偽陽性が生じてしまう）。


BloomFilterは、基本的にはHashTableの一種と見なせるが、明示的にキー=\\( k )\\-merを格納せず、Hash値のみを固定長の配列に持っておくことで、メモリの消費量を小さく抑えることができる。
具体的には、最初にメモリ消費量を決め打ちすることで、定数メモリと線形時間で動くような\\( k )\\-merの集合表現を提供する。

もちろん、Hash値しか持たないと、二つの\\( k )\\-merが同一のHash値を持ったときに、衝突が生じてしまう。

この問題を、BloomFilterは、一つのキーに対して、複数のHash値を計算して、こうして得られた『Hash値の集合』とキーのHash=フィンガープリントとして用いることで解決する。直感的には、**一つのHash関数で値が衝突することはあっても、100個のHash関数すべてで衝突することは起こりにくいだろう**ということだ。

内部では、巨大な0-filled なBitVectorを持っておき、各\\( k )\\-merに対するハッシュ関数たちを計算して、その値が指す番地をすべて1で埋める。当然、ハッシュ関数が多すぎると（例えば、100長のBitVectorに対して50個のHash関数を持つ）、BitVectorがしばらくするとすべて1になってしまい、どんなキーが来ても『集合に含まれる』と言ってしまうことに注意する。
一方で、表現する要素が2個しかないならば、ハッシュ関数はかなり多くとっても全く問題ない。

要するに、BloomFilterにおいては、BitVectorの長さ、Hash関数の数、そして挿入される要素の個数の間に、微妙な依存関係がある。理想的な状況では、少しの計算で、\\( p = ln2 *　M/N )\\　なる関係が導ける。ここで、\\( p )\\は最適なHash関数の個数、\\( M )\\はBitVecotrの長さ、\\( N )\\は挿入される要素の個数を表す。

さて、そうはいっても、上記のように『ハッシュ関数をたくさん用意して、ハッシュ値たちを計算して、BitVectorを埋める』といっても、実装ではいくつか注意することがある。

今回はRust言語を用いた際の実装に関して、いくつかメモを残しておく。


## 実装

### 実装全体について

- 変数そのものを渡すのと、変数への参照を渡すのは、それほど速度の違いが出ない。いちいち変数を返すのも大変なので、基本的には参照を使う。
- スライスとVector、配列の違いに注意すること。例えば、`&[&[u8]]`のつもりで`&Vec<Vec<u8>>`を渡さないこと。また、`Vec<T>`は（当然だが）要素の型が一致していないといけない。例えば`vec![b"ATAT",b"CTCTCTC"]`はだめ。`vec![b"ATAT".to_vec(),b"CTCTCTC".to_vec()]`はOK.
- たくさん呼ばれる、簡単な関数には#[inline]をつけること。インライン展開されて高速になる。
- （コードがきれいであって、そこが速度に影響する限り）速度を気をつけて書くこと。例えば、`x`が`true`なら`true`、そうでないなら`foo()`を返す、というコードは`if`を使わないで`x || foo()`と書いた方がほんのすこしはやい。`(x * y) mod p`も、`x * y`がオーバーフローしそうなときは、1に` + x mod p `を`y`回やるよりも早い方法がある。
- 実行するときは必ず`cargo [command] --release`とすること。`--release`を忘れると最適化がかからない。テストコードの一部

### 内部のBitVectorについて

BloomFilterが中に持っているBitVector(ソースでは`src/bitvector.rs`)を実装するときに、Vector<bool>を使っては**いけない**。
これは、Rustが持てる最小の単位がByte単位でBit単位ではないことに起因する。具体的には、boolは1bitではなく1byte分の大きさがある（LLVMの都合らしいが、よく知らない）。

今回の実装では、内部でVec<u64>を持ち、BitShitでアクセスしている。それ以外に特記することはない。Rank/Selectといった操作が不要なので、大体数十行で実装できる。


### Bloom Filterの実装について

型まわりがちゃんとわかっていれば簡単（わかっていないので簡単ではなかった）。Rolling hashを使うと、ある\\( k )\\-merのHash値から、次の\\( k )\\-merのHash値を定数時間で計算できる。

型についてだが、Rustはジェネリクスを持っている。また、型を分類するためにトレイトという仕組みが備わっていて、『あるメソッドが定義されている型ならなんでも』のような制約をつけることができる。

例えば、『8bit正数をもらって8bit正数を返す、何度でも関数のように呼べる』トレイトは`Fn(u8)->u8`というトレイトである。
なので、『8bit->8bitの関数をもらって、それを1で評価して、評価値を返す』高階関数は

```rust
fn foo<T>(x:T)->u8
where T:Fn(u8) -> u8{
      x(1)
}
```
のように書く。


ところで、BloomFilterはある自然数t個のハッシュ関数を持つのだが、どのように型をつければいいだろうか？　実は、素数の上での剰余類で考えているとき、ハッシュ関数に独立性ではなく、ペアワイズ独立性くらいの緩い条件しか課さないなら、二つハッシュ関数があればいいということが知られている。

実際に、ペアワイズ独立性を満たせばBloomFilterの運用には十分なことが多いので、今回はそれに習おう。直感的に言えば、BloomFilterは内部に二つの関数を持つ構造体になる。もう少しRustっぽくいうと、BloomFilterは、Fn(u8)->u8を実装するメンバを二つ持つ構造体になる：


```rust
struct BloomFilter<F>
where F:Fn(u8) -> u8
{
	hash1:F,
	hash2:F,
	/* Other fields omitted */
}

```

実際、このコードは次のような例ではうまく動く。
```rust
fn main(){
	let f = |x| x * 2;
	let _bf = BloomFilter{hash1:f.clone(), hash2:f};
	// continues
}
```

ところが、次のようなコードはコンパイルできない：

```rust
fn main(){
	let f = |x| x * 2;
	let g = |x| x * 2;
	let _bf = BloomFilter{hash1:f, hash2:g};
	// continues
}

```

実際、上のシグネチャは『Fn(u8)->u8を実装している型Tを二つ持つ』であって、『二つのFn(u8)->u8を実装している型を一つずつ持つ』ではない。**各クロージャはそれぞれユニークな型を持つ**ことを考えると、確かに上のコードをコンパイラが弾くのは正しい挙動になる。

よって、

```rust
struct BloomFilter<F,T>
where F:Fn(u8) -> u8,
      T:Fn(u8) -> u8

{
	hash1:F,
	hash2:T,
	/* Other fields omitted */
}

```
が正しいシグネチャになる。


さて、この構造体にimplするときも、少し注意が必要になる。例えば、Fn(u8)->u8を実装している型T,Fについて、BloomFilter<T,F>を作って、それにメソッドを定義したいときには、

```rust
impl<T,F> BloomFilter<F,T>
where F:Fn(u8)->u8,
	T:Fn(u8)->u8
{
	fn eval(&self)->u8{
		(self.hash1)(1) + (self.hash2)(1)
	}
}
fn main(){
	let f = |x| x * 2;
	let g = |x| x * 2;
	let bf = BloomFilter{hash1:f, hash2:g};
	println!("{}",bf.eval()) // 4
```

などとする。一方で、『デフォルトのBloomFilterを（自分で定義した）デフォルトの関数で定義したい』ときに

```rust

fn outer(x:u8)->u8{
	x * 2
}

impl<T,F> BloomFilter<F,T>
where F:Fn(u8)->u8,
	T:Fn(u8)->u8
{
	fn new()->Self{
		BloomFilter{
			hash1:outer,
			hash2:outer
		}
	}
}
fn main(){
	let _bf = BloomFilter::new();
}


```

はコンパイルできない。一方で、

```rust

fn outer(x:u8)->u8{
	x * 2
}

impl<T,F> BloomFilter<F,T>
where F:Fn(u8)->u8,
	T:Fn(u8)->u8
{
	fn new(h1:F,h2:T)->Self{
		BloomFilter{
			hash1:h1,
			hash2:h2,
		}
	}
}
fn main(){
	let _bf = BloomFilter::new(outer,outer);
}
```
はコンパイルできる！


これは一瞬不思議に思えるが、『外から関数を与える』ことと、『内側で関数を勝手に選ぶ』こととが異なることに注意すればいい。
つまり、後者のコードは、確かに、型は`BloomFilter::new()`を呼ぶ側(`main`)によって決められている一方で、
前者のコードでは（implは）『Fn(u8)->u8を実装している二つの型F,Tについてのジェネリクス』にも関わらず、関数（fn(u8)->u8という**型**を持つ）によって
一意に型が決まってしまったBloomFilterを返している。
事実、我々は`impl Fn(u8)->u8 for u8`などとすれば、u8にも`Fn(u8)->u8`を実装できてしまうため、この型への制限は厳しすぎる。

要するに、`BloomFilter<fn(u8)->u8, fn(u8)->u8 >`という具体的な型に対して実装すればいい。


```rust
fn outer(x:u8)->u8{
	x * 2
}

impl BloomFilter<fn(u8)->u8, fn(u8)->u8 >
{
	fn new()->Self{
		BloomFilter{
			hash1:outer,
			hash2:outer
		}
	}
}

impl<T,F> BloomFilter<F,T>
where F:Fn(u8)->u8,
	T:Fn(u8)->u8
{
	fn eval(&self)->u8{
		(self.hash1)(1) + (self.hash2)(1)
	}
}

fn main(){
	let bf = BloomFilter::new();
	println!("{}",bf.eval()); // 4
}

```

ここで、具体的な型として帰ってきた`bf:BloomFilter<fn(u8)->u8, fn(u8)->u8 >`について、`bf.eval()`はコンパイルが通ることに注意する。


このようにして、BloomFilter内に関数っぽいものを持たせられるようになったら、後は適当にBitVector等々をメンバにそろえてやれば、順当に実装できる。


結果としては、150Mbp程度の入力に対しては、`HashSet<Vec<u8>>`を扱うよりも、20％くらい早い\\( k )\\-merの表現を持つことができた。
（やってみたい方はrust `git clone git clone https://ban-m@bitbucket.org/yoh_ikkaidoh/handmade_bloom_filter.git && cd handmade_bloom_filter && cargo test --release -- --nocapture`とすると、望むらくは、再現できる）
